# Fast aggregation and the `dplyr` extension


One of the cornerstones of efficient R programming is so-called *vectorization*. The general idea is to operate on vectors or other large data structures at a time or with a single instruction. The specialization of this idea to R is to have a single function call perform a vector-level operation, while implementing most of the work in C or C++ or other low-level language. `plyrmr` is designed to encourage vectorized programming. For instance `gapply(data, fun)` will apply fun to sizable chunks of `data`, as data frames, if `data` is not grouped. It's up to the user to specify a vectorized `fun` function. If `data` is grouped by certain columns, the control of group size is left to the developer and the data, and groups could be very numerous and very small. This would imply a large number of calls to the R function `fun` which would result in an inefficient program. While there are programming techniques to cope with this problem, they are not transparent or straightforward. `rmr2` offers a *vectorized* form of reduce whereby multiple groups are processed by the same `reduce` call, thus restoring the opportunity to effectively vectorize the reduce phase. In exposing this feature in `plyrmr`, we made two design decisions. The first was, as in the case of *mergeability*, to centralize in the aggregation function the knowledge about whether the function can handle multiple groups or not. That way one can create a repertoire of vectorized aggregation functions that, when combined with any of the grouping functions, will trigger vectorized grouping, the same way a mergeable function will trigger the use of a combiner when possible. To make know to plyrmr that a function can handle multiple groups, use the `vectorized` function, as in `fun = vectorized(fun)`. The second design decision concerned the representation of the grouping information. In the usual, non-vectorized, grouping, all the data passed to one aggregation function call is for one group, so there isn't an immediate need to have a representation of it. On the other hand, in vectorized grouping the aggregation function needs to find out which data belongs to which group. As there isn't a standard way to represent that in data frames, we decided to use the `grouped_df` class form package `dplyr`. That allows you to directly use the aggregation functions in `dplyr` for the aggregation. If you don't want to,  you are still dealing with a data.frame and you can extract the names of the grouping columns with the function `groups`. Better yet, we can "teach" a few functions from `dplyr` to work on `plyrmr`'s data sets. To do that we just need to call `extend("dplyr")` which will add 6 generic functions to the current environment: `filter`, `mutate`, `summarize` and `summarize_mergeable`, the latter two with the alternative "summarise" spelling also available for speakers of British English. In this context, the two `summarize*` functions are the most useful. Use the `summarize_mergeable` variety when the required summary is associative and commutative, as in `summarize_mergeable(data, sum(col.1), sum(col.2))`, otherwise just `summarize` as in `summarize(data, mean(col.1), mean(col.2))`. The latter is more general, the former has important efficiency and scalability advantages.


