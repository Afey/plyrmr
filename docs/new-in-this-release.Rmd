---
title: "What's new in `plyrmr` 0.5.0"
output: 
  html_document:
    keep_md: true 
---

```{r echo = FALSE}
suppressMessages(library(plyrmr))
```

## Features

### New functions for big data sets: nrow, ncol, dim

They do what you expect them to do, but were a glaring omission among common data frame functions.

### New function VAR helps using plyrmr inside other functions

It is convenient to type `bind.cols(mtcars, cyl/2)`, but what do you do when you want to parametrize the data and the column? Typically, you are writing a function 

```{r}
half.some.column = function(data, col) bind.cols(data, col/2)
```

Should work right?

```{r error=TRUE}
half.some.column(mtcars, cyl)
half.some.column(mtcars, "cyl")
half.some.column(mtcars, as.name("cyl"))
```

Nada, nope, rien. Try `VAR`.

```{r}
half.some.column = function(data, col) bind.cols(data, VAR(col)/2)
head(half.some.column(mtcars, "cyl"))
```

Finally! And it works also with column numbers

```{r}
head(bind.cols(mtcars, z = VAR(1)/2))
```

### Automagically avoid useless recomputation

When dealing with big data, wasteful recomputation should not be taken lightly. `plyrmr` now does that on your behalf.

```{r echo=FALSE, results='hide'}
z = output(input(mtcars), "/tmp/mtcars")
```

```{r}
ncol(input("/tmp/mtcars"))
```
This does actual work,

```{r}
ncol(input("/tmp/mtcars"))
```
This one doesn't. It's that easy.

### Better naming for columns in count output

For example:
```{r}
count(mtcars, carb:cyl, carb:gear)
```

Let me try to spelly it out. For each ... argument, there are as many columns in the result as there are variables in that argument, plus 1. The last one is for the counts. The others are for the combination of values being counted. All the column names start with an id for the ... arg followed by a column specific part. The arg identifier is an underscore separated concatenation of variables in that argument. The column specific part is either the name of a variable or "freq". It's probably easier to look at the example.

### Function `summarize_mergeable`

When using the `dplyr` extension pack you may notice two new functions by a similar name: `summarize` and `summarize_mergeable`. The latter should be used when the summarization is associative and commutative, like a sum, to reap important performance benefits, but can't be used with operations like `mean`, which do no enjoy the same properties. It's the same as the `.mergeable` argument to `transmute`, but instead of trying to monkey patch `summarize` to accept an additional argument I went for the additional function. Remember `summarize` can only be used for single row summaries and gives important performance benefits when summarizing many small groups.

### Higher order function for creating data frame functions

Just a little convenience for when you'd like to apply the same vector function to each column of a data frame. 

```{r}
log.data.frame = each.column(log)
head(log.data.frame(mtcars))
```

With this function, you can do things like:

```{r}
gapply(input("/tmp/mtcars")), log.data.frame)
```


```{r echo=FALSE}
dfs.rmr("/tmp/mtcars")
```

### Dropped support for base functions transform and subset 

As part of a major clean-up of how non-standard evaluation is handled (a.k.a ... expression arguments), they are gone. They were in an  extension pack anyway and they required lots of complex code to deal with their own way of dealing with non standard eval arguments. There are plenty of alternatives anyway.


## Bugs



